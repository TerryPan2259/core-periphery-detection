classdef minres_cp < cpabst 
	methods (Access = public)
		function [C,P,Q,Qs,score,param,dt] = detect(self, G, param)
			C= [];  P = [];Q = Inf;score = [];
			ts = cputime;
			for it = 1:param.numRun
				[Ct,Pt,Qt,Qst,scoret] = self.grad_descent(G,param); 
				if Qt < Q % note that the smaller is better
					C = Ct;P = Pt;Q = Qt;score = scoret;Qs = Qst;
				end
			end
			dt = cputime-ts;
		end

		function [q,qs,score] = eval(self,G,x,varargin)
		end
		
		function param = initParam(self,param)
			if ~isfield(param,'name');param.solver = 'minres';end
			if ~isfield(param,'numRun');param.numRun = 10;end
			
			
			% for degree correction
			if ~isfield(param,'sigma');param.sigma = 0.1;end
			if ~isfield(param,'beta');param.beta = 0.1;end
			if ~isfield(param,'mu');param.mu = 1e-4;end
			if strcmp( param.name, 'be_cont_dcor' )	
				param.dcor = true;
			end
		end
		
	end
	methods (Access = private)
			
		function [C,P,Q,Qs,score] =  grad_descent(self, G, param)
			
			A = G.adjacency_matrix('binary');
			N = size(A,1);	
			deg = G.degree(); M = G.numEdge();
			
			x = rand(N,1);
			%Qx = trace( (A-x*x')' * (A-x*x') ); 
			Qx = 2*M-2*x'*A*x + (x'*x)^2 - sum(x.^4);
			while(true)
				alpha = 1;	
				while(true)
					%S = x'*x * eye(N) - diag(x.^2);
					%df = param.sigma * (-A* x + 2*S*x);
					df = param.sigma * (-A* x + (x'*x)*x - (x.^2).*x);
					
					xnew = x - alpha * df;
					xnew(xnew<0) = 0;
					%xnew = xnew/sqrt(xnew'*xnew);
					%Qxnew = trace( (A-xnew*xnew')' * (A-xnew*xnew') ); 
					Qxnew = 2*M-2*xnew'*A*xnew + (xnew'*xnew)^2 - sum(xnew.^4);
					if Qxnew  - Qx  <= param.sigma * df'*(xnew-x)
						break;
					end
					alpha = alpha * param.beta; 
				end	
				if abs(Qxnew  - Qx)/N < param.mu; 
					x = xnew;
					Qx = Qxnew;
					break;
				end
				x = xnew;
				Qx = Qxnew;
			end
			C = x;
			P = 1-C;	
			Q = Qx;
			Qs = Q;
			score = x;	
		end
	end
end
