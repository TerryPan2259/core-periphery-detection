classdef cpdetection
	methods (Access = public)
		 function [C,P,Q,Qs,score,model] = detect(varargin)
			self = varargin{1};
			A = varargin{2};
			model = [];
			if nargin >2
				model = varargin{3};
			end
			model = self.init_model(model);
			
			switch model.name
				case 'borgatti'
					cpd = borgatti_cp();
				case 'fabio'
					cpd = fabio_cp();	
				case 'recursive'
					cpd = recursive_cp();% appy single core/periphery detection recursively	
				case 'com_cp' 
					cpd = community_cp();% divide community and then divide core and periphery	
				case 'modular'
					cpd = modular_cp();
				case 'rw_cp'
					cpd = rw_cp();
				case 'hook_potts_cp'
					cpd = hook_potts_cp();
				case 'modularity_conductance'
					cpd = community();
					[D,Q,score] = cpd.detect(A,model);
					C = D(:,1); P = D(:,2);
					return;
				otherwise
					display ('unknown model name in cpdetection')
			end
			[C,P,Q,Qs,score,model] = cpd.detect(A,model);
			
			if isfield(model,'pval')
				slice = self.permutation_test(C,P,A,model);
				C = C(:,slice);P = P(:,slice);Qs = Qs(slice);Q = sum(Qs);
			end
			if size(C,2)>1	
				remove = any(C,1)==false;
				C(:,remove) =[];P(:,remove) =[];Qs(remove) = [];Q= sum(Qs);
			end	
		end
		
		function [model] = setQth(self,model,pval,N,rho)
			Alist = self.ergraph(rho,N,round(10/pval));		
			
			tmpmodel = model;
			tmpmodel.itnum = model.itnum;
			tmpmodel.disp = false;
			
			if strcmp(model.name, 'com_cp') 
				tmpmodel.communitymodel.itnum = 1;
			end
			
			parfor t = 1:length(Alist)
				[~,~,~,Qs] = self.detect(Alist{t},tmpmodel);
				Qst(t) = max(Qs);
			end
			model.qth = Qst(floor(length(Qst)*pval));
		end 
	end
	
	methods (Access = private)
		function model = init_model(self,model)
			if ~isfield(model,'name');model.name = 'borgatti';end
			if ~isfield(model,'palarell');model.palarell = false;end
		end
		
		function Alist = ergraph(self,rho,N,T)
			M = N*(N-1)/2;
			L = nchoosek(1:N,2);
			t = 1;
			Alist = cell(T,1);	
			while(t <=T)	
				m = binornd(M,full(rho));
				eidx = randsample(M,m,false);
				A = sparse(L(eidx,1),L(eidx,2),1,N,N);
				A = A + A'; 
				Alist{t,1} = A;
				t = t + 1;
			end
		end
	
		function significant = permutation_test(self,C,P,A,model)
			
			T = 500;	
			clear cpmodel;		
			cpmodel.name = 'kl';	
			cpd = borgatti_cp();
			significant = true(1,size(C,2));
			for cid = 1:size(C,2)
				slice = any(C(:,cid)+P(:,cid),2);
				As = A(slice,slice); % slice
				
				% preparation	
				n = size(As,1);L = nchoosek(1:n,2);eids = sub2ind([n,n],L(:,1),L(:,2));
				a = As(eids);	
				
				q = cpd.eval(As,C(:,cid));
				count = 0;
				for t = 1:T
					At = sparse(L(:,1),L(:,2),a(randsample(length(a),length(a))),n,n);% random permutation 
					At = At + At'; % symmetrise
					[~,~,qt]=cpd.detect(At,cpmodel);
					Qt(t,1) = qt;
					if q < qt
						count = count + 1;
						if round(count/T) >model.pval
							significant(cid) = false;
							break	
						end
					end
				end
			end	
		end
	end
end	
